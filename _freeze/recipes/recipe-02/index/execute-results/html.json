{
  "hash": "97ecdabf0a379be77af6eb86e8cf4ef4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2. Reading, inspecting, and writing datasets\"\nsubtitle: \"Basics of working with datasets in R\"\ndescription: |\n  This Recipe guides you through the process of reading, inspecting, and writing datasets using R packages and functions in a Quarto environment. You'll learn how to effectively combine code and narrative to create a reproducible document that can be shared with others.\ncategories: [recipes]\nexecute:\n  echo: true\n---\n\n\n\n\n\n::: {.callout}\n**{{< fa regular list-alt >}} Skills**\n\n- Loading packages into an R session\n- Reading datasets into R with `read_*()` functions\n- Inspecting datasets with `dplyr` functions\n- Writing datasets to a file with `write_*()` functions\n:::\n\n## Concepts and strategies\n\n### Quarto documents and code blocks\n\nAsk you will remember from Recipes 0 and 1, Quarto documents can combine prose and code. The prose is written in Markdown and the code is written in R^[ Code block can be written in other programming languages as well such as Python, Bash, *etc.*]. The code is contained in code blocks, which are opened by three backticks (`` ` ``), the name of the programming language, `r`, in curly braces `{r}` and three backticks (`` ` ``) to close the block. For example, the following minimal Quarto document contains an R code block:\n\n````yaml\n---\ntitle: My Quarto Document\nformat: pdf\n---\n\n# Goals\n\nThis script ...\n\n```{r}\n#| label: code-block-name\n\n# R code goes here\n```\n\nAs you can see in the code block, the ...\n\n````\n\nCode blocks have various options that can be added by using key-value pairs that are prefixed with `#| `. Some common key-value pairs we will use in this Recipe are:\n\n- `label`: A unique name for the code block. This is used to reference the code block.\n- `echo`: A boolean value (`true` or `false`) that determines whether the code is displayed in the output document.\n- `include`: A boolean value (`true` or `false`) that determines whether the output of the code is displayed in the output document.\n- `message`: A boolean value (`true` or `false`) that determines whether the messages from the code are displayed in the output document.\n\n### Setting up the environment\n\nBefore we can read, inspect, and write data, we need to load the packages that contain the functions we will use. We will use the `readr` package to read datasets into R and write datasets to disk and the `dplyr` package to inspect and transform (subset) the data.\n\nThere are a few ways to load packages into an R session. The most common way is to use the `library()` function. The `library()` function loads a package into the R session and stops the script if the package is not available on the current computing environment.\n\nFor example, the following code block loads the `readr` and `dplyr` packages into the R session:\n\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| label: load-packages\n\n# Load packages\nlibrary(readr) # for reading and writing data\nlibrary(dplyr) # for inspecting and transforming data\n```\n````\n:::\n\n\nThis code block assumes that the `readr` and `dplyr` packages are installed on the current computing environment. If the packages are not installed, the code block will stop and display an error message, such as:\n\n```plain\nError in library(readr) : there is no package called ‘readr’\n```\n\nThis error can be addressed by installing the missing package with `install.packages(\"readr\")` and then re-running the code block. This is not ideal for reproducibility, however, because the code block will stop if the package is not installed. We will consider a more reproducible approach later in the course.\n\n::: {.callout}\n**{{< fa medal >}} Dive deeper**\n\nIf you interested in learning about safeguarding package loading in a reproducible way, see the `renv` package. The `renv` package is a project-oriented workflow to create a reproducible environment for R projects. For more information, see the [renv documentation](https://rstudio.github.io/renv/articles/renv.html).\n:::\n\n### Understanding the data\n\nNow that we have our environment set up, we can read the dataset into R. But before we do, we should make sure that we understand the data by looking at the data documentation.\n\nThe dataset that we will read into our R session based on the Brown Corpus [@Francis1961]. I've created a data origin file that contains the data documentation for the Brown Corpus, as we can see in @tbl-brown-passives-do.\n\n\n::: {#tbl-brown-passives-do .cell tbl-cap='Data origin file for the Brown Corpus.'}\n\n```{.r .cell-code}\n# Read and display the data origin file\n\nread_csv(file = \"data/original/brown_passives_do.csv\") |>\n  kable() |>\n  kable_styling() |>\n  column_spec(1, width = \"15em\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> attribute </th>\n   <th style=\"text-align:left;\"> description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Resource name </td>\n   <td style=\"text-align:left;\"> Brown Corpus </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Data source </td>\n   <td style=\"text-align:left;\"> http://korpus.uib.no/icame/brown/bcm.html </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Data sampling frame </td>\n   <td style=\"text-align:left;\"> Edited American English prose from various genres, published in the United States during the calendar year 1961. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Data collection date(s) </td>\n   <td style=\"text-align:left;\"> Originally published in 1964, revised in 1971 and 1979. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Data format </td>\n   <td style=\"text-align:left;\"> Multiple formats including Form A (original), Form B (stripped version), Form C (tagged version), Bergen Forms I and II, and Brown MARC Form. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Data schema </td>\n   <td style=\"text-align:left;\"> 500 samples of approximately 2000 words each, covering a wide range of genres and styles. Includes coding for major and minor headings, special types (italics, bold, etc.), abbreviations, symbols, and other textual features. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> License </td>\n   <td style=\"text-align:left;\"> Use restricted for scholarly research in linguistics, stylistics, and other disciplines. Specific copyright restrictions detailed in the manual. </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;width: 15em; \"> Attribution </td>\n   <td style=\"text-align:left;\"> W. Nelson Francis and Henry Kucera, Brown University, 1964, revised 1971 and 1979. </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nThis data origin file provides an overview of the original data source. In this case, the dataset we will read into R is a subset of the Brown Corpus which is an aggregate of the use of passive voice. This dataset was developed by the authors of the `corpora` package [@R-corpora]. I've exported the dataset to a CSV file, which we will read into R.\n\nThe data dictionary which describes the dataset we will read appears in @tbl-brown-passives-dd.\n\n```r\n# Read and display the data documentation file\nread_csv(file = \"../data/derived/brown_passives_curated_dd.csv\") |>\n  kable() |>\n  kable_styling()\n```\n\n\n::: {#tbl-brown-passives-dd .cell tbl-cap='Data dictionary file for the Brown Corpus.'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> variable </th>\n   <th style=\"text-align:left;\"> name </th>\n   <th style=\"text-align:left;\"> variable_type </th>\n   <th style=\"text-align:left;\"> description </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> cat </td>\n   <td style=\"text-align:left;\"> Category </td>\n   <td style=\"text-align:left;\"> categorical </td>\n   <td style=\"text-align:left;\"> Genre categories represented by letters </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> passive </td>\n   <td style=\"text-align:left;\"> Passive </td>\n   <td style=\"text-align:left;\"> numeric </td>\n   <td style=\"text-align:left;\"> Number of passive verb phrases in the genre </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> n_w </td>\n   <td style=\"text-align:left;\"> Number of words </td>\n   <td style=\"text-align:left;\"> numeric </td>\n   <td style=\"text-align:left;\"> Number of words in the genre </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> n_s </td>\n   <td style=\"text-align:left;\"> Number of sentences </td>\n   <td style=\"text-align:left;\"> numeric </td>\n   <td style=\"text-align:left;\"> Number of sentences in the genre </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> name </td>\n   <td style=\"text-align:left;\"> Genre </td>\n   <td style=\"text-align:left;\"> categorical </td>\n   <td style=\"text-align:left;\"> Genre name </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nWith this information, we are now in a position to read and inspect the dataset.\n\n### Reading datasets into R with `readr`\n\nWe've now prepared our Quarto document by loading the packages we will use and and we have reviewed the dataset documentation so that we understand the dataset we will read into R. We are now ready to read the dataset into R.\n\nR provides a number of functions to read data of many types in R. We will explore many types of data and datasets in this course. For now, we will focus on reading rectangular data into R. Rectangular data is data that is organized in rows and columns, such as a spreadsheet.\n\nOne of the most common file formats for rectangular data is the comma-separated values (CSV) file. CSV files are text files in which lines represent rows and commas separate columns of data. For example, the sample CSV file snippet below contains three rows and three columns of data:\n\n```csv\n\"word\",\"frequency\",\"part_of_speech\"\n\"the\",69971,\"article\"\n\"of\",36412,\"preposition\"\n\"and\",28853,\"conjunction\"\n```\n\nA CSV file is a type of delimited file, which means that the data is separated by a delimiter. In the case of a CSV file, the delimiter is a comma. Other types of delimited files use different delimiters, such as tab-separated values (TSV) files which use a tab character as the delimiter, or even a pipe (`|`) or semicolon (`;`).\n\nThe `readr` package provides functions to read rectangular dataset into R. The `read_csv()` function reads CSV files, the `read_tsv()` function reads TSV files, and the `read_delim()` function reads other types of delimited files.\n\nLet's use the `read_csv()` function to read the `brown_passives_curated.csv` file into R. To do this we will use the `file = ` argument to specify the path to the file. Now, the file \"path\" is the location of the file on the computer. We can specify this path in two ways:\n\n- Relative path: The relative path is the path to the file relative to the current working directory. The current working directory is the directory in which the R session is running.\n- Absolute path: The absolute path is the path to the file from the root directory of the computer.\n\nFor most purpose, the relative path is the better option because it is more portable. For example, if you share your code with someone else, they may have a different absolute path to the file. However, they will likely have the same relative path to the file.\n\nLet's say that the directory structure of our project is as follows:\n\n```bash\nproject/\n├── data/\n│   ├── original/\n│   │   └── brown_passives_do.csv\n│   └── derived/\n│       └── brown_passives_curated.csv\n└── code/\n    └── reading-inspecting-writing.qmd\n```\n\nIn this case, the relative path from `reading-inspecting-writing.qmd` to the `brown_passives_curated.csv` file is `../data/derived/brown_passives_curated.csv`. The `..` means \"go up one directory\" and the rest of the path is the path to the file from the `project/` directory.\n\nWith this in mind, we can read the `brown_passives_curated.csv` file into R with the following code block:\n\n```r\n#| label: read-dataset-brown-passives-curated\n\n# Read the dataset\nbrown_passives_df <-\n  read_csv(file = \"../data/derived/brown_passives_curated.csv\")\n```\n\nRunning the above code chunk in our Quarto document will read the dataset into R and assign it to the `brown_passives_df` variable. It will also show the code used to read the dataset into R. Furthermore, so functions will display messages in the output. For example, the `read_csv()` function will display a message that various parsing options were used to read the dataset into R.\n\n\n::: {.cell}\n\n:::\n\n\nThis information can be helpful in an interactive session, as `read_csv()` tells us the dimensions of the dataset and the data types of each column.\nBut this output is not necessary, and is unnecessarily verbose in a reproducible document.\n\nWe can hide any messages produced by a function by using the `message = false` key-value pair in the code block. For example, the following code block will read the dataset into R and assign it to the `brown_passives_df` variable without displaying any messages:\n\n```r\n#| label: read-dataset-brown-passives-curated\n#| message: false\n\n# Read the dataset\nbrown_passives_df <-\n  read_csv(file = \"../data/derived/brown_passives_curated.csv\")\n```\n\nNo messages are displayed in the document output.\n\n### Inspecting datasets with `dplyr`\n\nThe objective of this section is to demonstrate how to inspect and transform (subset) datasets using the `dplyr` package. We will use the `dplyr` package to inspect the dataset we read into R in the previous section.\n\nReading a CSV file into R will create a data frame object. Thus, I assigned the result to `brown_passives_df`. The `df` suffix is a common naming convention for rectangular data frames. It is good practice to use a consistent naming convention for objects in your code. This makes it easier to understand the code and to avoid errors.\n\nLet's do get an overview of the dataset by using the `glimpse()` function from the `dplyr` package. The `glimpse()` function displays the dimensions of the data frame and the data types of each column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Preview\nglimpse(brown_passives_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> Rows: 15\n> Columns: 5\n> $ cat     <chr> \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\", \"M\", \"N…\n> $ passive <dbl> 892, 543, 283, 351, 853, 1034, 1460, 837, 2423, 352, 265, 104,…\n> $ n_w     <dbl> 101196, 61535, 40749, 39029, 82010, 110363, 173017, 69446, 181…\n> $ n_s     <dbl> 3684, 2399, 1459, 1372, 3286, 4387, 6537, 2012, 6311, 3983, 36…\n> $ name    <chr> \"press reportage\", \"press editorial\", \"press reviews\", \"religi…\n```\n\n\n:::\n:::\n\n\nIf we want a more, tabular-like view of the data, we can simply print the dataset frame to the console. It's worth mentioning, that all `readr` functions return tibbles, so we gain the benefits of tibbles when we read dataset into R with `readr` functions, one of which is that we do not have to worry that printing a data frame to the console, or our document, will print all of the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Print the data frame\nbrown_passives_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 15 × 5\n>    cat   passive    n_w   n_s name            \n>    <chr>   <dbl>  <dbl> <dbl> <chr>           \n>  1 A         892 101196  3684 press reportage \n>  2 B         543  61535  2399 press editorial \n>  3 C         283  40749  1459 press reviews   \n>  4 D         351  39029  1372 religion        \n>  5 E         853  82010  3286 skills / hobbies\n>  6 F        1034 110363  4387 popular lore    \n>  7 G        1460 173017  6537 belles lettres  \n>  8 H         837  69446  2012 miscellaneous   \n>  9 J        2423 181426  6311 learned         \n> 10 K         352  68599  3983 general fiction \n> 11 L         265  57624  3673 detective       \n> 12 M         104  14433   873 science fiction \n> 13 N         290  69909  4438 adventure       \n> 14 P         290  70476  4187 romance         \n> 15 R         146  21757   975 humour\n```\n\n\n:::\n:::\n\n\nBy default, printing tibbles will return the first 10 rows and all columns, unless the columns are too numerous to display width-wise.\n\n`dplyr` also provides a set of `slice_*()` functions which allow us to display the data in a tabular fashion, with some additional options. There are three `slice_*()` functions we will cover here:\n\n- `slice_head()`: Select the first `n` rows of the data frame.\n- `slice_tail()`: Select the last `n` rows of the data frame.\n- `slice_sample()`: Select a random sample of `n` rows from the data frame.\n\nFor example, the following code block will select the first 5 rows of the data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select the first 5 rows\nslice_head(brown_passives_df, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 5 × 5\n>   cat   passive    n_w   n_s name            \n>   <chr>   <dbl>  <dbl> <dbl> <chr>           \n> 1 A         892 101196  3684 press reportage \n> 2 B         543  61535  2399 press editorial \n> 3 C         283  40749  1459 press reviews   \n> 4 D         351  39029  1372 religion        \n> 5 E         853  82010  3286 skills / hobbies\n```\n\n\n:::\n:::\n\n\nWe can also select the last 5 rows of the data frame with the `slice_tail()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select the last 5 rows\nslice_tail(brown_passives_df, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 5 × 5\n>   cat   passive   n_w   n_s name           \n>   <chr>   <dbl> <dbl> <dbl> <chr>          \n> 1 L         265 57624  3673 detective      \n> 2 M         104 14433   873 science fiction\n> 3 N         290 69909  4438 adventure      \n> 4 P         290 70476  4187 romance        \n> 5 R         146 21757   975 humour\n```\n\n\n:::\n:::\n\n\nFinally, we can select a random sample of 5 rows from the data frame with the `slice_sample()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select a random sample of 5 rows\nslice_sample(brown_passives_df, n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 5 × 5\n>   cat   passive    n_w   n_s name           \n>   <chr>   <dbl>  <dbl> <dbl> <chr>          \n> 1 J        2423 181426  6311 learned        \n> 2 N         290  69909  4438 adventure      \n> 3 L         265  57624  3673 detective      \n> 4 C         283  40749  1459 press reviews  \n> 5 K         352  68599  3983 general fiction\n```\n\n\n:::\n:::\n\n\nThese functions can be helpful to get a sense of the dataset in different ways. In combination with `arrange()` function, we can also sort the data frame by a column or columns and then select the first or last rows.\n\nFor example, the following code block will sort the data frame by the `passive` column in ascending order and then select the first 5 rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort by the `passive` column and select the first 5 rows\nslice_head(arrange(brown_passives_df, passive), n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 5 × 5\n>   cat   passive   n_w   n_s name           \n>   <chr>   <dbl> <dbl> <dbl> <chr>          \n> 1 M         104 14433   873 science fiction\n> 2 R         146 21757   975 humour         \n> 3 L         265 57624  3673 detective      \n> 4 C         283 40749  1459 press reviews  \n> 5 N         290 69909  4438 adventure\n```\n\n\n:::\n:::\n\n\nIf we want to sort be descending order, we can surround the column name with `desc()`, `arrange(desc(passive))`.\n\nNow, the previous code block does what we want, but it is not very readable. Enter the pipe operator. The pipe operator `|>` is an operator which allows us to chain the output of one function to the input of another function. This allows us to write more readable code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrown_passives_df |>\n  arrange(passive) |>\n  slice_head(n = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 5 × 5\n>   cat   passive   n_w   n_s name           \n>   <chr>   <dbl> <dbl> <dbl> <chr>          \n> 1 M         104 14433   873 science fiction\n> 2 R         146 21757   975 humour         \n> 3 L         265 57624  3673 detective      \n> 4 C         283 40749  1459 press reviews  \n> 5 N         290 69909  4438 adventure\n```\n\n\n:::\n:::\n\n\nThe result is the same but the code makes more sense. We can read the code from left to right, top to bottom, which is the order in which the functions are executed.\n\n::: {.callout}\n**{{< fa medal >}} Dive deeper**\n\nThe native R pipe `|>` was introduced in R 4.1.0. If you are using an earlier version of R, you can use the `magrittr` package to load the pipe operator `%>%`.\n\nThere are certain advantages to using the `magrittr` pipe operator, including the ability to use the pipe operator to pass arguments to functions with placeholders. For more information, see the [magrittr documentation](https://magrittr.tidyverse.org/).\n:::\n\nIn addition to being more legible, using the pipe with each function on its own line allows us to add comments to each line of code. For example, the following code block is the same as the previous code block, but with comments added.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Sort by the passive column and select the first 5 rows\nbrown_passives_df |>\n  arrange(passive) |>\n  slice_head(n = 5)\n```\n:::\n\n\nIt is a good practice to add comments when writing code, as long as it makes the code more readable and easier to understand for others and for your future self! If the comments are too verbose, and only repeat what the code is 'saying', then don't include them.\n\n### Subsetting datasets with `dplyr`\n\nNow that we have a sense of the data, we can subset the dataset to create a variations of our original data frame. We can subset the data frame by selecting columns and/ or rows.\n\nIn the [R lesson](https://github.com/qtalr/lessons) \"Packages and Functions\", we saw that base R provides the bracket (`[]`) operator to subset data frames. The `dplyr` package provides functions to subset data frames which can be more readable and easier to use.\n\nLet's first look a selecting columns. The `select()` function allows us to select columns by name. For example, the following code block will select the `passive` and `n_w` columns from the data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select the `passive` and `n_w` columns\nselect(brown_passives_df, passive, n_w)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 15 × 2\n>    passive    n_w\n>      <dbl>  <dbl>\n>  1     892 101196\n>  2     543  61535\n>  3     283  40749\n>  4     351  39029\n>  5     853  82010\n>  6    1034 110363\n>  7    1460 173017\n>  8     837  69446\n>  9    2423 181426\n> 10     352  68599\n> 11     265  57624\n> 12     104  14433\n> 13     290  69909\n> 14     290  70476\n> 15     146  21757\n```\n\n\n:::\n:::\n\n\nBeyond selecting columns, we can also reorder columns and rename columns. For example, the following code block will select the `passive` and `n_w` columns, rename the `n_w` column to `num_words`, and reorder the columns so that `num_words` is the first column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select rename and reorder columns\nbrown_passives_df |>\n  select(num_words = n_w, passive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 15 × 2\n>    num_words passive\n>        <dbl>   <dbl>\n>  1    101196     892\n>  2     61535     543\n>  3     40749     283\n>  4     39029     351\n>  5     82010     853\n>  6    110363    1034\n>  7    173017    1460\n>  8     69446     837\n>  9    181426    2423\n> 10     68599     352\n> 11     57624     265\n> 12     14433     104\n> 13     69909     290\n> 14     70476     290\n> 15     21757     146\n```\n\n\n:::\n:::\n\n\n::: {.callout}\n**{{< fa medal >}} Dive deeper**\n\n`select()` also provides a number of helper functions to select columns. For example, we can use the `starts_with()` function inside the `select()` call to select columns that start with a certain string. Or we can select columns by their vector type by using `where(is.character)`.\n\nFor more information, see the [select() documentation](https://dplyr.tidyverse.org/reference/select.html) or use the `?select` command in the R console.\n:::\n\nBy selecting some columns and not others, we have effectively dropped the columns we did not select. If it is more effective to drop columns by name, we can use the `select()` function with the `-` operator. For example, the following code block will drop the `cat` column from the data frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Drop the `n_w` column\nbrown_passives_df |>\n  select(-cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 15 × 4\n>    passive    n_w   n_s name            \n>      <dbl>  <dbl> <dbl> <chr>           \n>  1     892 101196  3684 press reportage \n>  2     543  61535  2399 press editorial \n>  3     283  40749  1459 press reviews   \n>  4     351  39029  1372 religion        \n>  5     853  82010  3286 skills / hobbies\n>  6    1034 110363  4387 popular lore    \n>  7    1460 173017  6537 belles lettres  \n>  8     837  69446  2012 miscellaneous   \n>  9    2423 181426  6311 learned         \n> 10     352  68599  3983 general fiction \n> 11     265  57624  3673 detective       \n> 12     104  14433   873 science fiction \n> 13     290  69909  4438 adventure       \n> 14     290  70476  4187 romance         \n> 15     146  21757   975 humour\n```\n\n\n:::\n:::\n\n\nLet's now turn our attention to subsetting rows. The `filter()` function allows us to select rows by a logical condition. For example, the following code block will select rows where the values of the `passive` column are less than `<` 1,000:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select rows where `passive` is less than 1,000\nbrown_passives_df |>\n  filter(passive < 1000)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 12 × 5\n>    cat   passive    n_w   n_s name            \n>    <chr>   <dbl>  <dbl> <dbl> <chr>           \n>  1 A         892 101196  3684 press reportage \n>  2 B         543  61535  2399 press editorial \n>  3 C         283  40749  1459 press reviews   \n>  4 D         351  39029  1372 religion        \n>  5 E         853  82010  3286 skills / hobbies\n>  6 H         837  69446  2012 miscellaneous   \n>  7 K         352  68599  3983 general fiction \n>  8 L         265  57624  3673 detective       \n>  9 M         104  14433   873 science fiction \n> 10 N         290  69909  4438 adventure       \n> 11 P         290  70476  4187 romance         \n> 12 R         146  21757   975 humour\n```\n\n\n:::\n:::\n\n\nWe can also use the `filter()` function to select rows by a character string. For example, the following code block will select rows where the values of the `name` column are equal to `religion`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select rows where `name` is equal to `religion`\nbrown_passives_df |>\n  filter(name == \"religion\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 1 × 5\n>   cat   passive   n_w   n_s name    \n>   <chr>   <dbl> <dbl> <dbl> <chr>   \n> 1 D         351 39029  1372 religion\n```\n\n\n:::\n:::\n\n\nThe inequality operator `!=` can be used for character strings as well. To include multiple values, we can use the `%in%` operator. In this case we can pass a vector of values to the `filter()` function. For example, the following code block will select rows where the values of the `name` column are equal to `religion` or `learned`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Select multiple values\nbrown_passives_df |>\n  filter(name %in% c(\"religion\", \"learned\", \"detective\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n> # A tibble: 3 × 5\n>   cat   passive    n_w   n_s name     \n>   <chr>   <dbl>  <dbl> <dbl> <chr>    \n> 1 D         351  39029  1372 religion \n> 2 J        2423 181426  6311 learned  \n> 3 L         265  57624  3673 detective\n```\n\n\n:::\n:::\n\n\n::: {.callout}\n**{{< fa medal >}} Dive deeper**\n\nFor more sophisticated subsetting, we can use the `str_detect()` function from the `stringr` package to select rows where the values of the `name` column contain a certain string. This approach will be enhanced later in the course when we learn about [regular expressions](https://en.wikipedia.org/wiki/Regular_expression).\n:::\n\n### Writing datasets to a file with `readr`\n\nFinally, we can write data, including data frames, to a file with the `write_*()` functions from the `readr` package. The `write_*()` functions include:\n\n- `write_csv()`: Write a data frame to a CSV file.\n- `write_tsv()`: Write a data frame to a TSV file.\n- `write_delim()`: Write a data frame to a delimited file with the specified delimiter (`|`, `;`, *etc*).\n\nTo create a distinct data frame from the one we read into R, let's subset our `brown_passives_df` data frame by columns and rows to create a new data frame that contains only the `passive`, `n_w`, and `name` columns and only the rows where the values of the `passive` column are greater than `>` 1,000 and assign it to the `brown_passives_subset_df`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset the data frame\nbrown_passives_subset_df <-\n  brown_passives_df |>\n  select(passive, n_w, name) |>\n  filter(passive > 1000)\n```\n:::\n\n\nNow the following code block will write the `brown_passives_subset_df` data frame to a CSV file given the specified file path:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Write the data frame to a CSV file\nwrite_csv(\n  x = brown_passives_subset_df,\n  file = \"../data/derived/brown_passives_subset.csv\"\n)\n```\n:::\n\n\nGiven the example directory structure we saw earlier, our new file appears in the `data/derived/` directory.\n\n```bash\nproject/\n├── data/\n│   ├── original/\n│   │   └── brown_passives_do.csv\n│   └── derived/\n│       ├── brown_passives_curated.csv\n│       ├── brown_passives_curated_dd.csv\n│       └── brown_passives_subset.csv\n└── code/\n    └── reading-inspecting-writing.qmd\n```\n\nThere is much more to learn about reading, inspecting, and writing datasets in R. We will introduce more functions and techniques in the coming lessons. For now, we have learned how to read, inspect, and write datasets using R functions and Quarto code blocks!\n\n## Check your understanding\n\n1. <select class='webex-select'><option value='blank'></option><option value='answer'>TRUE</option><option value=''>FALSE</option></select> The `readr` package provides functions to read rectangular data into R.\n2. The <select class='webex-select'><option value='blank'></option><option value='answer'>echo</option><option value=''>message</option><option value=''>include</option></select> option in a code block determines whether the code is displayed in the output document.\n3. <select class='webex-select'><option value='blank'></option><option value=''>TRUE</option><option value='answer'>FALSE</option></select> The `dplyr` package provides functions to create data dictionaries.\n4. <select class='webex-select'><option value='blank'></option><option value=''>read_csv()</option><option value='answer'>read_tsv()</option><option value=''>read_delim()</option></select> is used to read tab-separated values (TSV) files.\n5. Which function is in `dplyr` is used to select columns by name? <select class='webex-select'><option value='blank'></option><option value='answer'>select()</option><option value=''>filter()</option><option value=''>slice_head()</option></select>\n6. <select class='webex-select'><option value='blank'></option><option value='answer'>TRUE</option><option value=''>FALSE</option></select> The R pipe operator `|>` allows us to chain the output of one function to the input of another function.\n\n## Lab preparation\n\nIn Lab 2 you will have the opportunity to apply the skills you learned in this Recipe to create a Quarto document that reads, inspects, and writes data.\n\nIn addition to the knowledge and skills you have developed in Labs 0 and 1, to complete [Lab 2](https://github.com/qtalr/lab-02), you will need to be able to:\n\n- Create code blocks in a Quarto document\n- Understand the purpose of the `label`, `echo`, `message`, and `include` options in a code block\n- Load packages into an R session with `library()`\n- Understand how to read and create file relative file paths\n- Read datasets into R with the `read_csv()` function\n- Inspect data frames with `dplyr` functions such as `glimpse()`, `slice_head()`, `slice_tail()`, `slice_sample()`, and `arrange()`.\n- Use the `|>` pipe operator to chain functions together.\n- Subset data frames with `dplyr` functions such as `select()` and `filter()`.\n- Write data frames to a file with the `write_csv()` function.\n\n## References\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}